<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Point Grey areaDetector driver</title>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type" />
</head>
<body>
  <div style="text-align: center">
    <h1>
      Point Grey areaDetector driver</h1>
    <h2>
      July 21, 2017</h2>
    <h2>
      Mark Rivers</h2>
    <h2>
      University of Chicago</h2>
  </div>
  <h2>
    Table of Contents</h2>
  <ul>
    <li><a href="#Introduction">Introduction</a></li>
    <li><a href="#Firmware">Camera firmware</a></li>
    <li><a href="#VideoModes">Video modes</a></li>
    <li><a href="#Format7Modes">Format7 modes</a></li>
    <li><a href="#PixelFormats">Pixel formats</a></li>
    <li><a href="#FrameRates">Frame rates</a></li>
    <li><a href="#Properties">Properties</a></li>
    <li><a href="#StandardParameters">Standard driver parameters</a></li>
    <li><a href="#DriverParameters">Point Grey specific driver parameters</a></li>
    <li><a href="#Configuration">Configuration</a></li>
    <li><a href="#MEDM_screens">MEDM screens</a></li>
  </ul>
  <h2 id="Introduction" style="text-align: left">
    Introduction</h2>
  <p>
    This is an <a href="http://www.aps.anl.gov/epics/">EPICS</a> <a href="areaDetector.html">
      areaDetector</a> driver for cameras from <a href="http://www.ptgrey.com">Point Grey</a>.
    These include IEEE 1394 Firewire DCAM, GigE, USB 2.0, and USB 3.0 cameras. The driver
    should work with any Point Grey camera. It has been tested on Firewire (Flea2),
    GigE (BlackFly, Flea3, Grasshopper3), and USB 3.0 (Grasshopper3) cameras. The driver
    has been tested on Windows and Linux with all 3 of these cameras. Note that Point
    Grey Firewire cameras can also be controlled by the generic areaDetector <a href="FirewireWinDoc.html">
      Windows Firewire driver</a> and the areaDetector <a href="http://controls.diamond.ac.uk/downloads/support/firewireDCAM/index.html">
        Linux Firewire driver</a>, which work with Firewire cameras from any vendor.
    However, this Point Grey driver provides access to some vendor-specific features
    like strobe outputs that are not available in the generic drivers.
  </p>
  <p>
    On Linux the Point Grey FlyCap2 SDK requires glibc version 2.14. This means it cannot
    be used on RHEL 6, but it can be used on RHEL 7, and Fedora 15 and higher. For USB
    3.0 cameras kernel version 3.5.0 or higher is required. This means USB 3.0 cameras
    require Fedora 18 or higher, or RHEL 7.0 or higher.
  </p>
  <p>
    This driver inherits from <a href="areaDetectorDoc.html#ADDriver">ADDriver</a>.
    It implements many of the parameters in <a href="areaDetectorDoxygenHTML/asyn_n_d_array_driver_8h.html">
      asynNDArrayDriver.h</a> and in <a href="areaDetectorDoxygenHTML/_a_d_driver_8h.html">
        ADArrayDriver.h</a>. It also implements a number of parameters that are specific
    to the Point Grey cameras. The <a href="areaDetectorDoxygenHTML/classpoint_grey.html">
      pointGrey class documentation</a> describes this class in detail.</p>
  <p>
    The Point Grey cameras use the <a href="http://damien.douxchamps.net/ieee1394/libdc1394/iidc/">
      IIDC/DCAM model</a> for controlling features like shutter time, white balance,
    frame sizes, shutter time, frame rates, etc. This model is used not only for the
    IEEE 1394 Firewire cameras, for which the IIDC/DCAM model was developed, but also
    for their USB and GigE cameras. The Point Grey driver thus has many similarities
    to the generic areaDetector <a href="FirewireWinDoc.html">Windows Firewire driver</a>
    and the areaDetector <a href="http://controls.diamond.ac.uk/downloads/support/firewireDCAM/index.html">
      Linux Firewire driver</a>. The FlyCapture2 SDK abstracts this model to a certain
    extent, which facilitates writing a driver that works with all of the Point Grey
    cameras.
  </p>
  <h2 id="Firmware" style="text-align: left">
    Camera firmware</h2>
  <p>
    Point Grey frequently updates the available firmware for each camera to add features
    and fix bugs. However, they are not very good about putting the link to the latest
    firmware on their Web site. They claim this is because they only put the firmware
    on the Web site once it has been tested on all camera models in the camera family
    on which that firmware runs. In practice the firmware version listed on the Web
    site is often old and buggy. I have encouraged them to make the latest firmware
    more easily available. At present one must e-mail the support team (support@ptgrey.com)
    and ask them if newer firmware is available for a particular camera, and if so to
    provide access to it. They normally do this by sending a link to a Dropbox folder.</p>
  <h2 id="VideoModes" style="text-align: left">
    Video modes</h2>
  <p>
    The DCAM specification defines standard video formats, and a set of video modes
    for each video format. Point Grey combines the video format and video mode into
    a single quantity they call VideoMode. The following table lists these standard
    video modes.
  </p>
  <p>
    Video mode Format7 is special. It allows defining an ROI on the camera to read out.
    The pixel resolution with which the size and position of this ROI can be defined
    can be queried, and is not necessarily a single pixel. In Format 7 the frame rate
    settings do not apply, and there is a another setting called PixelFormat that controls
    the video format, e.g. Mono8, Mono16, RGB8, etc.</p>
  <p>
    Most cameras only support a small subset of these standard modes. The EPICS record
    $(P)$(R)VideoMode is an mbbo record that only has choices for the video modes actually
    available on the specific camera in use. Since mbbo records only allow a maximum
    of 16 choices and there are 24 standard video modes, it is conceivable that all
    available videos modes would not be presented. In practice this is not a problem
    since no existing camera supports more than 16 video modes.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="2">
          <b>Point Grey Video Modes</b> </td>
      </tr>
      <tr>
        <th>
          Mode Number </th>
        <th>
          Mode Description </th>
      </tr>
      <tr>
        <td>
          0 </td>
        <td>
          160x120 YUV444 </td>
      </tr>
      <tr>
        <td>
          1 </td>
        <td>
          320x240 YUV422 </td>
      </tr>
      <tr>
        <td>
          2 </td>
        <td>
          640x480 YUV411 </td>
      </tr>
      <tr>
        <td>
          3 </td>
        <td>
          640X480 YUV422 </td>
      </tr>
      <tr>
        <td>
          4 </td>
        <td>
          640x480 RGB </td>
      </tr>
      <tr>
        <td>
          5 </td>
        <td>
          640x480 Mono8 </td>
      </tr>
      <tr>
        <td>
          6 </td>
        <td>
          640x480 Mono16 </td>
      </tr>
      <tr>
        <td>
          7 </td>
        <td>
          800x600 YUV422 </td>
      </tr>
      <tr>
        <td>
          8 </td>
        <td>
          800x600 RGB </td>
      </tr>
      <tr>
        <td>
          9 </td>
        <td>
          800x600 Mono8 </td>
      </tr>
      <tr>
        <td>
          10 </td>
        <td>
          1024x768 YUV422 </td>
      </tr>
      <tr>
        <td>
          11 </td>
        <td>
          1024x768 RGB </td>
      </tr>
      <tr>
        <td>
          12 </td>
        <td>
          1024x768 Mono8 </td>
      </tr>
      <tr>
        <td>
          13 </td>
        <td>
          800x600 Mono16 </td>
      </tr>
      <tr>
        <td>
          14 </td>
        <td>
          1024x768 Mono16 </td>
      </tr>
      <tr>
        <td>
          15 </td>
        <td>
          1280x960 YUV422 </td>
      </tr>
      <tr>
        <td>
          16 </td>
        <td>
          1280x960 RGB </td>
      </tr>
      <tr>
        <td>
          17 </td>
        <td>
          1280x960 Mono8 </td>
      </tr>
      <tr>
        <td>
          18 </td>
        <td>
          1600x1200 YUV422 </td>
      </tr>
      <tr>
        <td>
          19 </td>
        <td>
          1600x1200 RGB </td>
      </tr>
      <tr>
        <td>
          20 </td>
        <td>
          1600x1200 Mono8 </td>
      </tr>
      <tr>
        <td>
          21 </td>
        <td>
          1280x960 Mono16 </td>
      </tr>
      <tr>
        <td>
          22 </td>
        <td>
          1600x1200 Mono16 </td>
      </tr>
      <tr>
        <td>
          23 </td>
        <td>
          Format7 (user-defined) </td>
      </tr>
    </tbody>
  </table>
  <h2 id="Format7Modes" style="text-align: left">
    Format7 modes</h2>
  <p>
    When the video mode is Format7 then there is an available selection of Format7 modes.
    These modes are not defined in the IIDC/DCAM standard, but are specific to each
    vendor and camera. Typically Format7 mode 0 is the entire chip unbinned, and mode
    1 is often the entire chip with 2x2 binning. The supported Format7 modes are listed
    in the Point Grey Technical Reference Manual for each camera. The EPICS Format7Mode
    record is used to select the Format7 mode to use. This is an mbbo record and the
    enum choices are only those supported by the camera in use. The enum strings are
    of the form "Format7 mode # (NYxNY)", for example "0 (1920x1200)" or "1 (960x600)"
    for Format7 modes 0 and 1 respectively on a camera with 1920 x 1200 pixels.</p>
  <h2 id="PixelFormats" style="text-align: left">
    Pixel formats</h2>
  <p>
    When the video mode is Format7 then there is an available selection of PixelFormats.
    The available PixelFormats depend on the selected Format7 mode. Selection of a PixelFormat
    is done with the EPICS PixelFormat record. This is an mbbo record that only has
    choices that are valid for the currently selected Format7 mode. The enum values
    in this record are thus dynamic, and it is displayed in a separate GUI window that
    must be closed and re-opened when the Format7 mode changes in order to guarantee
    that it is displaying the currently valid PixelFormat choices.</p>
  <p>
    The following tables lists the standard pixel formats for video mode Format7. Note
    that typically only a few of these pixel formats are supported on a particular camera
    with a specific Format7 mode.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="2">
          <b>Point Grey Format7 Pixel Formats</b> </td>
      </tr>
      <tr>
        <th>
          Pixel Format Number </th>
        <th>
          Pixel Format Description </th>
      </tr>
      <tr>
        <td>
          0 </td>
        <td>
          Mono8 </td>
      </tr>
      <tr>
        <td>
          1 </td>
        <td>
          YUV411 </td>
      </tr>
      <tr>
        <td>
          2 </td>
        <td>
          YUV422 </td>
      </tr>
      <tr>
        <td>
          3 </td>
        <td>
          YUV444 </td>
      </tr>
      <tr>
        <td>
          4 </td>
        <td>
          RGB8 </td>
      </tr>
      <tr>
        <td>
          5 </td>
        <td>
          Mono16 </td>
      </tr>
      <tr>
        <td>
          6 </td>
        <td>
          RGB16 </td>
      </tr>
      <tr>
        <td>
          7 </td>
        <td>
          Mono16_Signed </td>
      </tr>
      <tr>
        <td>
          8 </td>
        <td>
          RGB16_Signed </td>
      </tr>
      <tr>
        <td>
          9 </td>
        <td>
          Raw8 </td>
      </tr>
      <tr>
        <td>
          10 </td>
        <td>
          Raw16 </td>
      </tr>
      <tr>
        <td>
          11 </td>
        <td>
          Mono12 </td>
      </tr>
      <tr>
        <td>
          12 </td>
        <td>
          Raw12 </td>
      </tr>
      <tr>
        <td>
          13 </td>
        <td>
          BGR </td>
      </tr>
      <tr>
        <td>
          14 </td>
        <td>
          BGRU </td>
      </tr>
      <tr>
        <td>
          15 </td>
        <td>
          BGR16 </td>
      </tr>
      <tr>
        <td>
          16 </td>
        <td>
          BGRU16 </td>
      </tr>
      <tr>
        <td>
          17 </td>
        <td>
          YUV422_JPEG </td>
      </tr>
    </tbody>
  </table>
  <h2 id="FrameRates" style="text-align: left">
    Frame rates</h2>
  <p>
    The following tables lists the standard IIDC/DCAM frame rates for video modes other
    than Format7. Selecting a video mode (other than Format7) defines the choice of
    available standard frame rates. Selecting a standard frame rate actually defines
    a range of frame rates that are available, and the actual frame rate can be adjusted
    within this range with the FrameRate property. The FrameRate property is controlled
    with the EPICS FrameRateAbsVal or AcquirePeriod records.
  </p>
  <p>
    Selection of a standard frame rate is done with the EPICS FrameRate record. This
    is an mbbo record that only has choices that are valid for the currently selected
    video mode. The enum values in this record are thus dynamic, and it is displayed
    in a separate GUI window that must be closed and re-opened when the video mode changes
    in order to guarantee that it is displaying the currently valid FrameRate choices.
    Note that not all frame rates are supported by the IIDC standard for every video
    mode, and even when a frame rate is supported by the standard it may not be implemented
    for a particular camera.
  </p>
  <p>
    In Format 7 the frame rate settings do not apply, and the frame rate is controlled
    solely by the FrameRate property.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="2">
          <b>Standard IIDC/DCAM Video Frame Rates</b> </td>
      </tr>
      <tr>
        <th>
          Frame Rate Number </th>
        <th>
          Frame Rate (Frames/second) </th>
      </tr>
      <tr>
        <td>
          0 </td>
        <td>
          1.875 </td>
      </tr>
      <tr>
        <td>
          1 </td>
        <td>
          3.75 </td>
      </tr>
      <tr>
        <td>
          2 </td>
        <td>
          7.5 </td>
      </tr>
      <tr>
        <td>
          3 </td>
        <td>
          15 </td>
      </tr>
      <tr>
        <td>
          4 </td>
        <td>
          30 </td>
      </tr>
      <tr>
        <td>
          5 </td>
        <td>
          60 </td>
      </tr>
      <tr>
        <td>
          6 </td>
        <td>
          120 </td>
      </tr>
      <tr>
        <td>
          7 </td>
        <td>
          240 </td>
      </tr>
    </tbody>
  </table>
  <h2 id="Properties" style="text-align: left">
    Properties</h2>
  <p>
    The DCAM specification defines a number of standard features, which control things
    such as the brightness, white balance, shutter time, etc. For each feature the standard
    defines control in both device units (12-bit integers) and absolute units (floating
    point). For example shutter time may support absolute seconds, as well as device
    units. A feature may or may not be supported on a particular camera. If it is supported
    it may or may not permit control in absolute units. Each feature may support both
    manual control and automatic control (e.g. automatic gain control).
  </p>
  <p>
    Point Grey supports 18 of these DCAM features, which they call Properties.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="3">
          <b>Point Grey Camera Properties</b> </td>
      </tr>
      <tr>
        <th>
          Property Number </th>
        <th>
          EPICS Record Base Name </th>
        <th>
          Point Grey PropertyType enum </th>
      </tr>
      <tr>
        <td>
          0 </td>
        <td>
          Brightness </td>
        <td>
          BRIGHTNESS </td>
      </tr>
      <tr>
        <td>
          1 </td>
        <td>
          AutoExposure </td>
        <td>
          AUTO_EXPOSURE </td>
      </tr>
      <tr>
        <td>
          2 </td>
        <td>
          Sharpness </td>
        <td>
          SHARPNESS </td>
      </tr>
      <tr>
        <td>
          3 </td>
        <td>
          WhiteBalance </td>
        <td>
          WHITE_BALANCE </td>
      </tr>
      <tr>
        <td>
          4 </td>
        <td>
          Hue </td>
        <td>
          HUE </td>
      </tr>
      <tr>
        <td>
          5 </td>
        <td>
          Saturation = </td>
        <td>
          SATURATION </td>
      </tr>
      <tr>
        <td>
          6 </td>
        <td>
          Gamma </td>
        <td>
          GAMMA </td>
      </tr>
      <tr>
        <td>
          7 </td>
        <td>
          Iris </td>
        <td>
          IRIS </td>
      </tr>
      <tr>
        <td>
          8 </td>
        <td>
          Focus </td>
        <td>
          FOCUS </td>
      </tr>
      <tr>
        <td>
          9 </td>
        <td>
          Zoom </td>
        <td>
          ZOOM </td>
      </tr>
      <tr>
        <td>
          10 </td>
        <td>
          Pan </td>
        <td>
          PAN </td>
      </tr>
      <tr>
        <td>
          11 </td>
        <td>
          Tilt </td>
        <td>
          TILT </td>
      </tr>
      <tr>
        <td>
          12 </td>
        <td>
          Shutter </td>
        <td>
          SHUTTER </td>
      </tr>
      <tr>
        <td>
          13 </td>
        <td>
          Gain </td>
        <td>
          GAIN </td>
      </tr>
      <tr>
        <td>
          14 </td>
        <td>
          TriggerMode </td>
        <td>
          TRIGGER_MODE </td>
      </tr>
      <tr>
        <td>
          15 </td>
        <td>
          TriggerDelay </td>
        <td>
          TRIGGER_DELAY </td>
      </tr>
      <tr>
        <td>
          16 </td>
        <td>
          FrameRate </td>
        <td>
          FRAME_RATE </td>
      </tr>
      <tr>
        <td>
          17 </td>
        <td>
          Temperature </td>
        <td>
          TEMPERATURE </td>
      </tr>
    </tbody>
  </table>
  <h2 id="GigEProperties" style="text-align: left">
    GigE Properties</h2>
  <p>
    Point Grey supports 4 properties that are specific to GigE cameras.
  </p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="3">
          <b>Point Grey Camera Properties</b> </td>
      </tr>
      <tr>
        <th>
          Property Number </th>
        <th>
          EPICS Record Base Name </th>
        <th>
          Point Grey PropertyType enum </th>
      </tr>
      <tr>
        <td>
          0 </td>
        <td>
          Heeartbeat </td>
        <td>
          HEARTBEAT </td>
      </tr>
      <tr>
        <td>
          1 </td>
        <td>
          HeartbeatTimeout </td>
        <td>
          HEARTBEAT_TIMEOUT </td>
      </tr>
      <tr>
        <td>
          2 </td>
        <td>
          PacketSize </td>
        <td>
          PACKET_SIZE </td>
      </tr>
      <tr>
        <td>
          3 </td>
        <td>
          PacketDelay </td>
        <td>
          PACKET_DELAY </td>
      </tr>
    </tbody>
  </table>
  <h2 id="StandardParameters" style="text-align: left">
    Standard areaDetector parameters</h2>
  <p>
    The following table describes how the Point Grey driver implements some of the standard
    driver parameters.
  </p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="3">
          <b>Implementation of Parameters in asynNDArrayDriver.h and ADDriver.h, and EPICS Record
            Definitions in ADBase.template and NDFile.template</b> </td>
      </tr>
      <tr>
        <th>
          Parameter index variable </th>
        <th>
          EPICS record name </th>
        <th>
          Description </th>
      </tr>
      <tr>
        <td>
          ADTriggerMode </td>
        <td>
          $(P)$(R)TriggerMode </td>
        <td>
          The choices for the Point Grey are:
          <ul>
            <li>"Internal". The timing is internal to the detector.</li>
            <li>"Ext. standard". Each external trigger pulse starts the next image. The exposure
              time is controlled internally by the AcquireTime record.</li>
            <li>"Bulb". The rising edge of the external trigger signal starts the next image.
              The detector continues to acquire while the external signal is high, and then reads
              out the detector on the falling edge of the external trigger signal.</li>
            <li>"Skip frames". One external trigger pulse starts an image and then the next N
              external trigger signals are ignored. The SkipFrames record defines N.</li>
            <li>"Multi-exposure". One external trigger pulse starts an image and then the next
              N-1 external trigger signals cause an additional exposure into the same image. The
              image is read out after trigger N. The NumExposures record defines N.</li>
            <li>"Multi-exposure bulb". A combination of bulb and multi-exposure modes above. N
              exposures are accumulated into an image before it is read out. The time in the logic
              high state determines the acquire time for each exposure. The NumExposures record
              defines N.</li>
            <li>"Low-smear". Smear reduction works by increasing the speed of the vertical clock
              near the end of the integration cycle. See the Technical Reference Manual for the
              camera for more information.</li>
            <li>"Multi-shot". A single external trigger causes N images to be acquired. The NumImages
              record defines N. NumImages is limited to a maximum 255 in this mode.</li>
          </ul>
          Note that the minimum time between external trigger pulses is no more than the maximum
          value of FrameRate in the current mode, and may be less for a particular camera.
          Note also that not all cameras support all TriggerModes. The TriggerMode enum string
          choices are only those supported for the camera in use. </td>
      </tr>
      <tr>
        <td>
          ADTemperatureActual </td>
        <td>
          $(P)$(R)TemperatureActual </td>
        <td>
          The readback of the temperature. </td>
      </tr>
      <tr>
        <td>
          ADNumImages </td>
        <td>
          $(P)$(R)NumImages </td>
        <td>
          Controls the number of images to acquire. When TriggerMode=Internal this is handled
          in software. When TriggerMode=Multi-shot it is handled in the camera firmware.
        </td>
      </tr>
      <tr>
        <td>
          ADNumExposures </td>
        <td>
          $(P)$(R)NumExposures </td>
        <td>
          Controls the number of exposures per image when TriggerMode="Multi-exposure" or
          "Multi-exposure bulb". </td>
      </tr>
      <tr>
        <td>
          ADAcquireTime </td>
        <td>
          $(P)$(R)AcquireTime </td>
        <td>
          Controls the acquisition time per image. This is converted into the ShutterAbsVal
          control of the SHUTTER property. ShutterAbsVal = AcquireTime*1000., because SHUTTER
          units are ms. </td>
      </tr>
      <tr>
        <td>
          ADAcquirePeriod </td>
        <td>
          $(P)$(R)AcquirePeriod </td>
        <td>
          Controls the period between images. This is converted into the FrameRateAbsVal control
          of the FRAME_RATE property. FrameRateAbsVal = 1./AcquirePeriod. </td>
      </tr>
      <tr>
        <td>
          ADGain </td>
        <td>
          $(P)$(R)Gain </td>
        <td>
          Controls the analog gain on the camera. This is converted into the GainAbsVal control
          of the GAIN property. The units are dB. </td>
      </tr>
    </tbody>
  </table>
  <h2 id="DriverParameters">
    Point Grey specific driver parameters</h2>
  <p>
    The Point Grey driver implements the following parameters in addition to those in
    asynNDArrayDriver.h and ADDriver.h. The database file is pointGrey.template for
    all records except the property records, which are in pointGreyProperty.template.
  </p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="7">
          <b>Parameter Definitions in firewireWinDCAM.cpp and EPICS Record Definitions</b>
        </td>
      </tr>
      <tr>
        <th>
          Parameter index variable </th>
        <th>
          asyn interface </th>
        <th>
          Access </th>
        <th>
          Description </th>
        <th>
          drvInfo string </th>
        <th>
          EPICS record name </th>
        <th>
          EPICS record type </th>
      </tr>
      <tr>
        <td align="center" colspan="7">
          <b>Video mode parameters</b> </td>
      </tr>
      <tr>
        <td>
          PGVideoMode </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The video mode. All possible values are listed in the <a href="#VideoModes">Video
            modes</a> section above. The actual enum choices for this record will only include
          the video modes supported by the camera in use. </td>
        <td>
          PG_VIDEO_MODE </td>
        <td>
          $(P)$(R)VideoMode<br />
          $(P)$(R)VideoMode_RBV </td>
        <td>
          mbbo
          <br />
          mbbi </td>
      </tr>
      <tr>
        <td>
          PGFormat7Mode </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The Format7 mode when the camera is in VideoMode=Format7. This is discussed in the
          <a href="#Format7Modes">Format7 modes</a> section above. The actual enum choices
          for this record will only include the Format7 modes supported by the camera in use.
        </td>
        <td>
          PG_FORMAT7_MODE </td>
        <td>
          $(P)$(R)Format7Mode<br />
          $(P)$(R)Format7Mode_RBV </td>
        <td>
          mbbo
          <br />
          mbbi </td>
      </tr>
      <tr>
        <td>
          PGPixelFormat </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The pixel format when the camera is in VideoMode=Format7. This is discussed in the
          <a href="#PixelFormats">Pixel formats</a> section above. The actual enum choices
          for this record will only include the pixel formats supported by the camera in use
          for the Format7Mode currently selected. </td>
        <td>
          PG_PIXEL_FORMAT </td>
        <td>
          $(P)$(R)PixelFormat<br />
          $(P)$(R)PixelFormat_RBV </td>
        <td>
          mbbo
          <br />
          mbbi </td>
      </tr>
      <tr>
        <td>
          PGConvertPixelFormat </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The driver allows converting the pixel format from the camera to another pixel format.
          The pixel formats from the camera that can be converted are:
          <ul>
            <li>Raw8</li>
            <li>Raw12</li>
            <li>Raw16</li>
            <li>Mono12</li>
          </ul>
          The pixel format that these can be converted to are:
          <ul>
            <li>None: The input pixel format is not converted.</li>
            <li>Mono8: The input pixel format is converted to Mono8.</li>
            <li>Raw16: The input pixel format is converted to Raw16. This is useful when the input
              pixel format is Raw12, since this saves network bandwidth.</li>
            <li>Mono16: The input pixel format is converted to Mono16. This is useful when the
              input pixel format is Mono12, since this saves network bandwidth. Note that the
              FlyCap2 library does not support converting Raw12 to Mono16. The difference between
              Raw16 and Mono16 is that Mono16 has the sharpness and gamma corrections applied,
              while Raw16 does not.</li>
            <li>RGB8: The input format is converted to RGB8. This is useful when the input format
              is Raw8, for a color camera. In this case Bayer color is sent on the network, reducing
              the bandwidth requirement by a factor of 3.</li>
            <li>RGB16: The input format is converted to RGB16. This is useful when the input format
              is Raw16, for a color camera. In this case Bayer color is sent on the network, reducing
              the bandwidth requirement by a factor of 3.</li>
          </ul>
        </td>
        <td>
          PG_CONVERT_PIXEL_FORMAT </td>
        <td>
          $(P)$(R)ConvertPixelFormat<br />
          $(P)$(R)ConvertPixelFormat_RBV </td>
        <td>
          mbbo
          <br />
          mbbi </td>
      </tr>
      <tr>
        <td>
          PGFrameRate </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The frame rate choice when the VideoMode is not Format7. This is discussed in the
          <a href="#FrameRates">Frame rates</a> section above. The actual enum choices for
          this record will only include the frame rates supported by the camera in use for
          the VideoMode currently selected. </td>
        <td>
          PG_FRAME_RATE </td>
        <td>
          $(P)$(R)FrameRate<br />
          $(P)$(R)FrameRate_RBV </td>
        <td>
          mbbo
          <br />
          mbbi </td>
      </tr>
      <tr>
        <td>
          BinningMode </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The binning mode for GigE cameras. The allowed values are camera-specific.</td>
        <td>
          PG_BINNING_MODE </td>
        <td>
          $(P)$(R)BinningMode<br />
          $(P)$(R)BinningMode_RBV </td>
        <td>
          mbbo
          <br />
          mbbi </td>
      </tr>
      <tr>
        <td align="center" colspan="7">
          <b>Property parameters<br />
            These parameters apply to each of the 18 Point Grey properties discussed in the
            <a href="#Properties">Properties</a> section above.
            <br />
            The $(PROPERTY) macro in this table is the EPICS record base name listed in that
            section.<br />
            These records are defined in pointGreyProperty.template.</b> </td>
      </tr>
      <tr>
        <td>
          PGPropertyAvail </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          A flag indicating if the property is available. </td>
        <td>
          PG_PROP_AVAIL </td>
        <td>
          $(P)$(R)$(PROPERTY)Avail </td>
        <td>
          bi </td>
      </tr>
      <tr>
        <td>
          PGPropertyOnOffAvail </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          A flag indicating if the property supports turning on and off. </td>
        <td>
          PG_PROP_ON_OFF_AVAIL </td>
        <td>
          $(P)$(R)$(PROPERTY)OnOffAvail </td>
        <td>
          bi </td>
      </tr>
      <tr>
        <td>
          PGPropertyOnOff </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          Controls whether the property is on or off. </td>
        <td>
          PG_PROP_ON_OFF </td>
        <td>
          $(P)$(R)$(PROPERTY)OnOff
          <br />
          $(P)$(R)$(PROPERTY)OnOff_RBV </td>
        <td>
          bo
          <br />
          bi </td>
      </tr>
      <tr>
        <td>
          PGPropertyOnePushAvail </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          A flag indicating if the property supports setting once (called One Push). This
          is typically used for setting things like the gain or shutter time automatically
          once.</td>
        <td>
          PG_PROP_ONE_PUSH_AVAIL </td>
        <td>
          $(P)$(R)$(PROPERTY)OnePushAvail </td>
        <td>
          bi </td>
      </tr>
      <tr>
        <td>
          PGPropertyOnePush </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          Processing this record causes a one-push setting of the property. </td>
        <td>
          PG_PROP_ONE_PUSH </td>
        <td>
          $(P)$(R)$(PROPERTY)OnePush</td>
        <td>
          bo</td>
      </tr>
      <tr>
        <td>
          PGPropertyAbsAvail </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          A flag indicating if the property supports absolute (floating point) control.
        </td>
        <td>
          PG_PROP_ABS_AVAIL </td>
        <td>
          $(P)$(R)$(PROPERTY)AbsAvail </td>
        <td>
          bi </td>
      </tr>
      <tr>
        <td>
          PGPropertyAutoAvail </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          A flag indicating if the property supports automatic control. </td>
        <td>
          PG_PROP_AUTO_AVAIL </td>
        <td>
          $(P)$(R)$(PROPERTY)AutoAvail </td>
        <td>
          bi </td>
      </tr>
      <tr>
        <td>
          PGPropertyManAvail </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          A flag indicating if the property supports manual control. </td>
        <td>
          PG_PROP_MAN_AVAIL </td>
        <td>
          $(P)$(R)$(PROPERTY)ManAvail </td>
        <td>
          bi </td>
      </tr>
      <tr>
        <td>
          PGPropertyAutoMode </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          Controls whether the property is manually controlled or automatically controlled.
        </td>
        <td>
          PG_PROP_AUTO_MODE </td>
        <td>
          $(P)$(R)$(PROPERTY)AutoMode
          <br />
          $(P)$(R)$(PROPERTY)AutoMode_RBV </td>
        <td>
          bo
          <br />
          bi </td>
      </tr>
      <tr>
        <td>
          PGPropertyAbsAvail </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          A flag indicating if the property supports absolute (floating point) control.
        </td>
        <td>
          PG_PROP_ABS_AVAIL </td>
        <td>
          $(P)$(R)$(PROPERTY)AbsAvail </td>
        <td>
          bi </td>
      </tr>
      <tr>
        <td>
          PGPropertyAbsMode </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          Controls whether the property is controlled in integer device units or floating
          point absolute units. </td>
        <td>
          PG_PROP_ABS_MODE </td>
        <td>
          $(P)$(R)$(PROPERTY)AbsMode
          <br />
          $(P)$(R)$(PROPERTY)AbsMode_RBV </td>
        <td>
          bo
          <br />
          bi </td>
      </tr>
      <tr>
        <td>
          PGPropertyValue </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The value of the property in integer device units. This controls the ValueA field
          of the property, which is the only integer field used for all properties except
          WHITE_BALANCE. </td>
        <td>
          PG_PROP_VAL </td>
        <td>
          $(P)$(R)$(PROPERTY)Val
          <br />
          $(P)$(R)$(PROPERTY)Val_RBV </td>
        <td>
          ao
          <br />
          ai </td>
      </tr>
      <tr>
        <td>
          PGPropertyValueB </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The value of the property in integer device units. This controls the ValueB field
          of the property, which is only used to control the Blue value of WHITE_BALANCE.
        </td>
        <td>
          PG_PROP_VAL_B </td>
        <td>
          $(P)$(R)$(PROPERTY)ValB
          <br />
          $(P)$(R)$(PROPERTY)ValB_RBV </td>
        <td>
          ao
          <br />
          ai </td>
      </tr>
      <tr>
        <td>
          PGPropertyValueMin </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          The minimum value of the property in device units. This is used to control the LOPR
          and DRVL fields of the $(P)$(R)$(PROPERTY)Val record. </td>
        <td>
          PG_PROP_VAL_MIN </td>
        <td>
          $(P)$(R)$(PROPERTY)ValMin </td>
        <td>
          ai </td>
      </tr>
      <tr>
        <td>
          PGPropertyValueMax </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          The maximum value of the property in device units. This is used to control the HOPR
          and DRVH fields of the $(P)$(R)$(PROPERTY)Val record. </td>
        <td>
          PG_PROP_VAL_MAX </td>
        <td>
          $(P)$(R)$(PROPERTY)ValMax </td>
        <td>
          ai </td>
      </tr>
      <tr>
        <td>
          PGPropertyValueAbs </td>
        <td>
          asynFloat64 </td>
        <td>
          r/w </td>
        <td>
          The value of the property in floating point absolute units. </td>
        <td>
          PG_PROP_VAL_ABS </td>
        <td>
          $(P)$(R)$(PROPERTY)ValAbs
          <br />
          $(P)$(R)$(PROPERTY)ValAbs_RBV </td>
        <td>
          ao
          <br />
          ai </td>
      </tr>
      <tr>
        <td>
          PGPropertyValueAbsMin </td>
        <td>
          asynFloat64 </td>
        <td>
          r/o </td>
        <td>
          The minimum value of the property in absolute units. This is used to control the
          LOPR and DRVL fields of the $(P)$(R)$(PROPERTY)ValAbs record. </td>
        <td>
          PG_PROP_VAL_ABS_MIN </td>
        <td>
          $(P)$(R)$(PROPERTY)ValAbsMin </td>
        <td>
          ai </td>
      </tr>
      <tr>
        <td>
          PGPropertyValueAbsMax </td>
        <td>
          asynFloat64 </td>
        <td>
          r/o </td>
        <td>
          The maximum value of the property in absolute units. This is used to control the
          HOPR and DRVH fields of the $(P)$(R)$(PROPERTY)ValAbs record. </td>
        <td>
          PG_PROP_VAL_ABS_MAX </td>
        <td>
          $(P)$(R)$(PROPERTY)ValAbsMax </td>
        <td>
          ai </td>
      </tr>
      <tr>
        <td align="center" colspan="7">
          <b>GigE Property parameters<br />
            These parameters apply to each of the 4 Point Grey GigE properties discussed in
            the <a href="#GigEProperties">GigE Properties</a> section above.
            <br />
            The $(PROPERTY) macro in this table is the EPICS record base name listed in that
            section.<br />
            These records are defined in pointGreyProperty.template.</b> </td>
      </tr>
      <tr>
        <td>
          PGPropertyValue </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The value of the property in integer device units. This controls the ValueA field
          of the property, which is the only integer field used for all properties except
          WHITE_BALANCE. </td>
        <td>
          PG_PROP_VAL </td>
        <td>
          $(P)$(R)$(PROPERTY)Val
          <br />
          $(P)$(R)$(PROPERTY)Val_RBV </td>
        <td>
          ao
          <br />
          ai </td>
      </tr>
      <tr>
        <td>
          PGPropertyValueMin </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          The minimum value of the property in device units. This is used to control the LOPR
          and DRVL fields of the $(P)$(R)$(PROPERTY)Val record. </td>
        <td>
          PG_PROP_VAL_MIN </td>
        <td>
          $(P)$(R)$(PROPERTY)ValMin </td>
        <td>
          ai </td>
      </tr>
      <tr>
        <td>
          PGPropertyValueMax </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          The maximum value of the property in device units. This is used to control the HOPR
          and DRVH fields of the $(P)$(R)$(PROPERTY)Val record. </td>
        <td>
          PG_PROP_VAL_MAX </td>
        <td>
          $(P)$(R)$(PROPERTY)ValMax </td>
        <td>
          ai </td>
      </tr>
      <tr>
        <td align="center" colspan="7">
          <b>Trigger parameters</b> </td>
      </tr>
      <tr>
        <td>
          PGTriggerSource </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The trigger source signal. Choices are "GPIO_0", GPIO_1","GPIO_2", and "GPIO_3",
          which selects one of 4 GPIO pins on the camera. However, not all choices may be
          available on a specific camera, and the enum choices will only be the trigger sources
          actually supported on the camera in use. </td>
        <td>
          PG_TRIGGER_SOURCE </td>
        <td>
          $(P)$(R)TriggerSource
          <br />
          $(P)$(R)TriggerSource_RBV </td>
        <td>
          mbbo
          <br />
          mbbi </td>
      </tr>
      <tr>
        <td>
          PGTriggerPolarity </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The trigger polarity. Choices are "Low", and "High". </td>
        <td>
          PG_TRIGGER_POLARITY </td>
        <td>
          $(P)$(R)TriggerPolarity
          <br />
          $(P)$(R)TriggerPolarity_RBV </td>
        <td>
          bo
          <br />
          bi </td>
      </tr>
      <tr>
        <td>
          PGSoftwareTrigger </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          Processing this record causes the driver to issue a software trigger. </td>
        <td>
          PG_SOFTWARE_TRIGGER </td>
        <td>
          $(P)$(R)SoftwareTrigger </td>
        <td>
          bo </td>
      </tr>
      <tr>
        <td>
          PGSkipFrames </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The number of frames to skip when TriggerMode="Skip frames". </td>
        <td>
          PG_SKIP_FRAMES </td>
        <td>
          $(P)$(R)SkipFrames
          <br />
          $(P)$(R)SkipFrames_RBV </td>
        <td>
          longout
          <br />
          longin </td>
      </tr>
      <tr>
        <td align="center" colspan="7">
          <b>Strobe parameters</b> </td>
      </tr>
      <tr>
        <td>
          PGStrobeSource </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The strobe output signal. Choices are "GPIO_0", GPIO_1","GPIO_2", and "GPIO_3",
          which selects one of 4 GPIO pins on the camera. However, not all choices may be
          available on a specific camera, and the enum choices will only be the strobe sources
          actually supported on the camera in use. </td>
        <td>
          PG_STROBE_SOURCE </td>
        <td>
          $(P)$(R)StrobeSource
          <br />
          $(P)$(R)StrobeSource_RBV </td>
        <td>
          mbbo
          <br />
          mbbi </td>
      </tr>
      <tr>
        <td>
          PGStrobeEnable </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          Enables the strobe output. Choices are "Disable", and "Enable". </td>
        <td>
          PG_STROBE_ENABLE </td>
        <td>
          $(P)$(R)StrobeEnable
          <br />
          $(P)$(R)StrobeEnable_RBV </td>
        <td>
          bo
          <br />
          bi </td>
      </tr>
      <tr>
        <td>
          PGStrobePolarity </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The strobe polarity. Choices are "Low", and "High". </td>
        <td>
          PG_STROBE_POLARITY </td>
        <td>
          $(P)$(R)StrobePolarity
          <br />
          $(P)$(R)StrobePolarity_RBV </td>
        <td>
          bo
          <br />
          bi </td>
      </tr>
      <tr>
        <td>
          PGStrobeDelay </td>
        <td>
          asynFloat64 </td>
        <td>
          r/w </td>
        <td>
          The delay of the strobe signal relative to the start of acquisition. </td>
        <td>
          PG_STROBE_DELAY </td>
        <td>
          $(P)$(R)StrobeDelay
          <br />
          $(P)$(R)StrobeDelay_RBV </td>
        <td>
          ao
          <br />
          ai </td>
      </tr>
      <tr>
        <td>
          PGStrobeDuration </td>
        <td>
          asynFloat64 </td>
        <td>
          r/w </td>
        <td>
          The duration of the strobe signal. If zero then the strobe output is asserted during
          the image aquisition time. </td>
        <td>
          PG_STROBE_DURATION </td>
        <td>
          $(P)$(R)StrobeDuration
          <br />
          $(P)$(R)StrobeDuration_RBV </td>
        <td>
          ao
          <br />
          ai </td>
      </tr>
      <tr>
        <td align="center" colspan="7">
          <b>Bandwidth control parameters</b> </td>
      </tr>
      <tr>
        <td>
          PGMaxPacketSize</td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          The maximum packet size. This depends on the current acquisition settings for Firewire
          and USB cameras. For GigE cameras this is determined by calling DiscoverGigEPacketSize
          at startup, which should return the maximum Ethernet packet size supported between
          the camera and the IOC. However, this sometimes returns 9000 (jumbo packets) when
          jumbo packets are not in fact supported. In this case the user should manually set
          PacketSize to 1440 or image acquisition will fail.</td>
        <td>
          PG_MAX_PACKET_SIZE </td>
        <td>
          $(P)$(R)MaxPacketSize</td>
        <td>
          longin </td>
      </tr>
      <tr>
        <td>
          PGPacketSize </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The packet size to use. This is used to control the maximum bandwidth, and hence
          maximum frame rate, on Firewire and USB cameras. For GigE cameras it should be set
          to the largest packet size supported on the Ethernet connection between the camera
          and IOC. It should be set to 1440 for connections that do not support jumbo packets,
          and as large as 9000 for connections that do support jumbo packets. If PacketSize
          is set to 0 then the driver will use the current value of MaxPacketSize.</td>
        <td>
          PG_PACKET_SIZE </td>
        <td>
          $(P)$(R)PacketSize
          <br />
          $(P)$(R)PacketSize_RBV </td>
        <td>
          ao
          <br />
          ai </td>
      </tr>
      <tr>
        <td>
          PGPacketSizeActual </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          The actual packet size being used.</td>
        <td>
          PG_PACKET_SIZE_ACTUAL </td>
        <td>
          $(P)$(R)PacketSizeActual</td>
        <td>
          longin </td>
      </tr>
      <tr>
        <td>
          PGPacketDelay </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The packet delay to use in microseconds. This is used to control the maximum bandwidth,
          and hence maximum frame rate, on GigE cameras. It is not used for Firewire or USB
          cameras. The default is 400 microseconds. If the number of CorruptFrames is large
          then this can be increased, for example to 1000. This will reduce the maximum frame
          rate but can significantly reduce the number of CorruptFrames.</td>
        <td>
          PG_PACKET_DELAY </td>
        <td>
          $(P)$(R)PacketDelay
          <br />
          $(P)$(R)PacketDelay_RBV </td>
        <td>
          longout
          <br />
          longin </td>
      </tr>
      <tr>
        <td>
          PGPacketDelayActual </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          The actual packet delay being used.</td>
        <td>
          PG_PACKET_DELAY_ACTUAL </td>
        <td>
          $(P)$(R)PacketDelayActual</td>
        <td>
          longin </td>
      </tr>
      <tr>
        <td>
          PGBandwidth </td>
        <td>
          asynFloat64 </td>
        <td>
          r/o </td>
        <td>
          The calculated bandidth in MB/s. This is computed from the image size and the frame
          rate.</td>
        <td>
          PG_BANDWIDTH </td>
        <td>
          $(P)$(R)Bandwidth</td>
        <td>
          ai </td>
      </tr>
      <tr>
        <td align="center" colspan="7">
          <b>Timestamp parameters</b> </td>
      </tr>
      <tr>
        <td>
          PGTimeStampMode </td>
        <td>
          asynInt32 </td>
        <td>
          r/w </td>
        <td>
          The timestamp mode. Controls the value of the NDArray,.timeStamp value. Choices
          are:
          <ul>
            <li>Camera: The time from the camera is used.</li>
            <li>EPICS: The EPICS time is used</li>
            <li>Hybrid: The EPICS time when the camera started is combined with the time stamp
              from the camera.</li>
          </ul>
        </td>
        <td>
          PG_TIME_STAMP_MODE </td>
        <td>
          $(P)$(R)TimeStampMode
          <br />
          $(P)$(R)TimeStampMode_RBV </td>
        <td>
          mbbo
          <br />
          mbbi </td>
      </tr>
      <tr>
        <td align="center" colspan="7">
          <b>Camera statistics</b> </td>
      </tr>
      <tr>
        <td>
          PGCorruptFrames </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          The number of corrupt frames. The Point Grey SDK resets this to 0 each time acquisition
          is started. </td>
        <td>
          PG_CORRUPT_FRAMES </td>
        <td>
          $(P)$(R)CorruptFrames_RBV </td>
        <td>
          longin </td>
      </tr>
      <tr>
        <td>
          PGDroppedFrames </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          The number of dropped frames. The Point Grey SDK resets this to 0 each time acquisition
          is started. </td>
        <td>
          PG_DROPPED_FRAMES </td>
        <td>
          $(P)$(R)DroppedFrames_RBV </td>
        <td>
          longin </td>
      </tr>
      <tr>
        <td>
          PGDriverDropped </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          The number of frames dropped by the driver. The Point Grey SDK resets this to 0
          each time acquisition is started. </td>
        <td>
          PG_DRIVER_DROPPED </td>
        <td>
          $(P)$(R)DriverDropped_RBV </td>
        <td>
          longin </td>
      </tr>
      <tr>
        <td>
          PGTransmitFailed </td>
        <td>
          asynInt32 </td>
        <td>
          r/o </td>
        <td>
          The number of time transmission failed. The Point Grey SDK resets this to 0 each
          time acquisition is started. </td>
        <td>
          PG_TRANSMIT_FAILED </td>
        <td>
          $(P)$(R)TransmitFailed_RBV </td>
        <td>
          longin </td>
      </tr>
    </tbody>
  </table>
  <h2 id="Configuration">
    Configuration</h2>
  <p>
    The Point Grey driver is created with the pointGreyConfig command, either from C/C++
    or from the EPICS IOC shell.</p>
  <pre>pointGreyConfig(const char *portName, const char* cameraId, int traceMask, int memoryChannel,
              int maxBuffers, size_t maxMemory, 
              int priority, int stackSize)
  </pre>
  <p>
    The cameraId parameter can either be an index of the camera in the list of available
    cameras (e.g. 0 if there is only a single Point Grey camera available) or the serial
    number of the camera to use. For additional details on the meaning of the parameters
    to this function refer to the detailed documentation on the pointGreyConfigConfig
    function in the <a href="areaDetectorDoxygenHTML/point_grey_8cpp.html">pointGrey.cpp
      documentation</a> and in the documentation for the constructor for the <a href="areaDetectorDoxygenHTML/classpoint_grey.html">
        pointGrey class</a>.
  </p>
  <p>
    The traceMask can be set to a value &gt; 1 to enable asynTrace debugging during
    initialization, before the value can be set from the IOC shell or via the asynRecord.
    Set this to 0x21 to enable ASYN_TRACE_WARNING, which will trace all calls to the
    Point Grey FlyCap2 library.</p>
  <p>
    The memoryChannel can be set to a value &gt; 0 to load the initial camera parameters
    from non-volatile memory in the camera. Setting memoryChannel to N loads from memoryChannel
    N-1, i.e. 1 loads memory channel 0. There is currently a problem with Linux and
    for BlackFly GigE cameras. If the IOC is run a second time after it has been used
    to acquire any images the driver loses communication with the camera. The problem
    appears to be that there is a corrupt setting in the camera, which causes it to
    malfunction the next time the program is run. Setting memoryChannel 1 will work
    around this problem by replacing the settings in the camera with a default set.
    Since the EPICS IOC sets nearly all the camera settings to save/restore values at
    startup anyway, this is not a serious limitation.</p>
  <p>
    There an example IOC boot directory and startup script (<a href="point_grey_st_cmd.html">iocBoot/iocPointGrey/st.cmd)</a>
    provided with areaDetector.
  </p>
  <h2 id="MEDM_screens" style="text-align: left">
    MEDM screens</h2>
  <p>
    The following show the MEDM screens that are used to control the Point Grey cameras.</p>
  <p>
    <code>pointGrey.adl</code> is the main screen used to control Point Grey cameras.
  </p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      pointGrey.adl</h3>
    <img alt="pointGrey.png" src="pointGrey.png" /></div>
  <p>
    <code>pointGreyProperties.adl</code> is the screen used to control the properties
    of Point Grey cameras. Note that some of these properties, such as Shutter, FrameRate,
    and Gain can also be controlled by standard areaDetector records, like AcquireTime,
    AcquirePeriod, and Gain. The widgets on the medm screen are hidden if the corresponding
    feature is not available.
  </p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      pointGreyProperties.adl for a BlackFly GigE color camera in RGB mode</h3>
    <img alt="pointGreyProperties_BlackFly.png" src="pointGreyProperties_BlackFly.png" />
    <h3 style="text-align: center">
      pointGreyProperties.adl for a Grasshopper3 monochrome camera</h3>
    <img alt="pointGreyProperties_Grasshopper3.png" src="pointGreyProperties_Grasshopper3.png" /></div>
  <p>
    <code>pointGreyFrameRate.adl</code> is the screen used to control the frame rate
    in standard video modes. This is a separate screen because the valid enum strings
    for the Framerate record can change when the standard video mode is changed. When
    that is changed it is necessary to close this screen and re-open it in order for
    the new menus to be displayed. This is a limitation of the EPICS Channel Access
    which does not send monitor events for changes in enum fields. Note that the readback
    of the FrameRate on the main pointGrey.adl screen can also be incorrect, so it may
    be necessary to close and re-open that main screen as well.
  </p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      pointGreyFrameRate.adl</h3>
    <img alt="pointGreyFrameRate.png" src="pointGreyFrameRate.png" /></div>
  <p>
    <code>pointGreyPixelFormat.adl</code> is the screen used to control the pixel format
    in Format7 mode. This is a separate screen because the valid enum strings for the
    PixelFormat can change when the Format7 mode is changed. When that is changed it
    is necessary to close this screen and re-open it in order for the new menus to be
    displayed. This is a limitation of the EPICS Channel Access which does not send
    monitor events for changes in enum fields. Note that the readback of the PixelFormat
    on the main pointGrey.adl screen can also be incorrect, so it may be necessary to
    close and re-open that main screen as well.
  </p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      pointGreyPixelFormat.adl</h3>
    <img alt="pointGreyPixelFormat.png" src="pointGreyPixelFormat.png" /></div>
</body>
</html>
